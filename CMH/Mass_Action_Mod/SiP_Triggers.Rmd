---
title: "Shelter in Place Triggers"
author: "Chris Hoover"
date: "6/4/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      fig.height = 6,
                      fig.width = 8)

require(deSolve)
require(tidyverse)

```

# Purpose  
Evaluate potential triggers to intervene on COVID transmission (e.g. shelter in place or other method to reduce contact and transmission) from signals in testing data. 

```{r epi_data}
# Case and hosptialization data for SF
sf_hosp <- read.csv(url("https://data.sfgov.org/resource/nxjg-bhem.csv")) %>% 
  mutate(Date = as.Date(reportdate),
         type = ifelse(dphcategory == "ICU", "ICU", "HOSP"),
         conf = ifelse(covidstatus == "PUI", "PUI", "CONF"),
         hosp_stat = paste(type, conf, sep = "_")) %>% 
  pivot_wider(names_from = hosp_stat,
              values_from = patientcount) %>%
  group_by(Date) %>% 
  summarise(ICU_PUI = sum(ICU_PUI, na.rm = T),
            ICU_CONF = sum(ICU_CONF, na.rm = T),
            HOSP_PUI = sum(HOSP_PUI, na.rm = T),
            HOSP_CONF = sum(HOSP_CONF, na.rm = T)) %>% 
  arrange(Date) %>% 
  mutate(HOSP_tot = ICU_CONF + HOSP_CONF,
         HOSP_max = ICU_CONF + HOSP_CONF + ICU_PUI + HOSP_PUI,
         cumICUconf = cumsum(ICU_CONF),
         cumICUpui = cumsum(ICU_PUI),
         cumHOSPconf = cumsum(HOSP_CONF),
         cumHOSPpui = cumsum(HOSP_PUI))

sf_case <- read.csv(url("https://data.sfgov.org/resource/tvq9-ec9w.csv")) %>% 
  mutate(Date = as.Date(date)) %>% 
  pivot_wider(names_from = case_disposition,
              values_from = case_count) %>% 
  group_by(Date) %>% 
  summarise(Cases = sum(Confirmed, na.rm = T),
            Deaths = sum(Death, na.rm = T)) %>% 
  arrange(Date) %>% 
  mutate(cum_case = cumsum(Cases),
         cum_death = cumsum(Deaths))

sf_test <- read.csv(url("https://data.sfgov.org/resource/nfpa-mg4g.csv")) %>% 
  mutate(Date = as.Date(result_date)) %>% 
  arrange(Date) %>% 
  mutate(cum_tests = cumsum(tests),
         cum_pos = cumsum(pos))

sf_all <- sf_test %>% 
  dplyr::select(Date, tests, pos, neg, pct, indeterminate, cum_tests, cum_pos) %>%
  full_join(sf_case, by = "Date") %>% 
  full_join(sf_hosp, by = "Date")
```

## Testing  
```{r test_plot}
sf_test_plot_df <- sf_test %>% 
  mutate(tests_10k = tests/10000,
         tests_7dayavg = zoo::rollmean(tests,7,na.pad = T,align = "right"),
         tests100s_7dayavg = zoo::rollmean(tests/100,7,na.pad = T,align = "right"),
         pos_7day_avg = zoo::rollmean(pos,7,na.pad = T,align = "right")) %>%
  dplyr::select(Date, tests100s_7dayavg, pos_7day_avg) %>% 
  pivot_longer(-Date, names_to = "Test", values_to = "Num")

test_plot <- sf_test_plot_df %>% 
  ggplot() +
    geom_line(aes(x = Date, y = Num, col = Test),
              size = 1.1) +
    theme_bw() +
    scale_color_manual(values = c("purple", "gold"),
                       labels = c("Positive tests",
                                  "Tests\nconducted (100s)")) +
    scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day") +
    theme(axis.title = element_text(size = 14,
                                    face = "bold"),
          axis.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45,
                                     hjust = 1)) +
    labs(x = "Date",
         y = "Tests and Positives (7-day average)",
         col = "",
         title = "COVID19 testing in SF")

test_plot

```

# Model  
We use a slight tweak to LEMMA to add an explicit deaths compartment in order to fit to deaths data in addition to hospitalizations  

\begin{align*}
\dot{S}&=-\beta S(I_R+I_H)/N \\
\dot{E}&=\beta S(I_R+I_H)/N-\sigma E \\
\dot{I_R}&=\sigma(1-\alpha) E-\gamma_R I_R \\
\dot{I_H}&=\sigma\alpha E-\rho I_H \\
\dot{H}&=\rho I_H-\gamma_H H \\
\dot{D}&=\gamma_H\mu H \\
\dot{R}&=\gamma_R I_R \gamma_H(1-\mu)H\\
\end{align*}

```{r mod_prep, include=FALSE}
# Key Dates
t0 <- as.Date("2020-02-15")

# Beta change dates
schools.close <- as.Date("2020-03-05") #Schools closed
SiP.start <- as.Date("2020-03-15")     #SiP announced
SiP2 <- as.Date("2020-04-15")          #Another knot
SiP3 <- as.Date("2020-05-15")          #Another knot
today <- as.Date(Sys.Date()-1)         #Another knot today
t.end <- as.Date("2020-07-15")         # Where we're headed (for future use)

t.tot <- as.numeric(t.end - t0)

# Transmission parameter estimates
get_R <- function(beta, alpha, gam_r, gam_h, S, N){
  ((beta*(1-alpha))/gam_r + (beta*alpha)/gam_h)*S/N
}

get_beta <- function(R, alpha, gam_r, gam_h){
  (R*gam_r*gam_h)/((1-alpha)*gam_h+alpha*gam_r*gam_h)
}

#Starting covid parameters
pop.size <- 883305
t.sim <- as.numeric(today - t0)

lemma_pars <- list(N = pop.size,
                   t.sim = t.sim,
                   E.start = 2,
                   cr = 1,
                   ch = 1,
                   sigma = 1/3,
                   alpha = 0.05,
                   rho = 1/4,
                   gam_r = 1/5,
                   gam_h = 1/12,
                   mu = 0.2)

beta.init <- get_beta(3, lemma_pars[["alpha"]], lemma_pars[["gam_r"]], lemma_pars[["rho"]])

beta.time <- cbind(-as.numeric(t0-c(t0, schools.close,
                                    SiP.start, SiP2, SiP3, today, t.end)),
                   log(beta.init*c(1, 1, 0.6, 0.4, 0.5, 0.5, 0.7)))

beta_smooth <- splinefun(x = beta.time[,1],
                         y = beta.time[,2],
                         method = "natural")

beta_fx <- approxfun(c(1:t.tot),
                     c(rep(log(beta.init),beta.time[2,1]), sapply(c(beta.time[2,1]+1):t.tot,
                                                                  beta_smooth)))

beta_smooth2 <- approxfun(x = beta.time[,1],
                          y = beta.time[,2],
                          method = "linear")

plot(c(1:150), exp(sapply(1:150, beta_fx)), type = "l")
  lines(c(1:150), exp(sapply(1:150, beta_smooth2)), col = 4)
  points(x = beta.time[,1],
         y = exp(beta.time[,2]),
         pch = 17, col = "red")

```

```{r mod_odes}
lemma_odes = function(t, n, p, fx) { 

  # States
    S = n[1]
    E = n[2]
    Ir = n[3]
    Ih = n[4]
    H = n[5]
    D = n[6]
    R = n[7]
  
  # Parameters
    N = p[['N']]             #population size
    cr = p[['cr']]           #Relative contact rate between S and Ir
    ch = p[['ch']]           #Relative contact rate between S and Ih
    sigma = p[['sigma']]     #1/serial interval
    alpha = p[['alpha']]     #proportion severely symptomatic
    rho = p[['rho']]         #1/time between symptom onset and hospitalization
    gam_r = p[['gam_r']]     #1/time to recovery (non-infectiousness) for mild/asymptomatic
    gam_h = p[['gam_h']]     #1/time to removed (recovered or deceased) for hospitalized
    mu = p[['mu']]           #proportion of hospitalized cases who die

  #Movement forcing function
    beta = exp(fx(t))
  
  # Model equations
    dSdt = -S*beta*(Ir*cr+Ih*ch)/N
    
    dEdt = S*beta*(Ir*cr+Ih*ch)/N - E*sigma
    
    dIrdt = E*(1-alpha)*sigma - Ir*gam_r
    
    dIhdt = E*alpha*sigma - Ih*rho

    dHdt = Ih*rho - H*gam_h
    
    dDdt = H*gam_h*mu
    
    dRdt = Ir*gam_r+H*gam_h*(1-mu)

    return(list(c(dSdt, dEdt, dIrdt, dIhdt, dHdt, dDdt, dRdt)))
    
} 
```

```{r test_fit, eval=FALSE}
test.pars <- lemma_pars
test.pars[["E.start"]] <- 2

  init <- c(S = test.pars[["N"]] - test.pars[["E.start"]],
            E = test.pars[["E.start"]],
            Ir = 0,
            Ih = 0,
            H = 0,
            D = 0,
            R = 0)


test.sim <- as.data.frame(ode(y = init, 
                              times = 1:test.pars[["t.sim"]], 
                              parms = test.pars,
                              func = lemma_odes, 
                              fx = beta_fx)) %>% 
  mutate(Date = as.Date(t0+time-1)) 

test.sim$Re <- get_R(exp(sapply(1:test.pars[["t.sim"]], beta_fx)),
                     test.pars[["alpha"]], test.pars[["gam_r"]], test.pars[["rho"]], test.sim$S, test.pars[["N"]])


ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_line(data = test.sim,
            aes(x = Date, y = H),
            col = "coral", size = 1.2) +
  geom_point(data = sf_all,
             aes(x = Date, y = HOSP_tot),
             pch = 17) +
  scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day")

ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_line(data = test.sim,
            aes(x = Date, y = D),
            col = "coral", size = 1.2) +
  geom_point(data = sf_all,
             aes(x = Date, y = cum_death),
             pch = 17) +
  scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day")
  
ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_line(data = test.sim,
            aes(x = Date, y = Re),
            col = "coral", size = 1.2) +
  scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day")

```

## Model fit  

```{r fit_fx}
#Function to return fit from input parameters and data
  lemma_fit <- function(fit.pars, all.pars, fit_data) {
    use.pars <- all.pars
    use.pars[["alpha"]] <- fit.pars[3]
    use.pars[["mu"]] <- fit.pars[4]
        
    beta_smooth <- splinefun(x = beta.time[2:6,1],
                             y = log(c(fit.pars[2],
                                       fit.pars[5],
                                       fit.pars[6],
                                       fit.pars[7],
                                       fit.pars[8])),
                             method = "natural")
  
    beta_fx <- approxfun(c(1:use.pars[["t.sim"]]),
                         c(log(rep(fit.pars[2],beta.time[2,1])), 
                           sapply(c(beta.time[2,1]+1):use.pars[["t.sim"]],
                                  beta_smooth)))

    # initial number of exposed as parameter
    init <- c(S = as.numeric(use.pars[["N"]] - fit.pars[1]),
              E = as.numeric(fit.pars[1]),
              Ir = 0,
              Ih = 0,
              H = 0,
              D = 0,
              R = 0)
    
    # Run the model with input parameters to generate predicted quantities
    mod.run <- as.data.frame(ode(y = init, 
                                 times = 1:use.pars[["t.sim"]], 
                                 parms = use.pars,
                                 func = lemma_odes, 
                                 fx = beta_fx)) %>% 
      mutate(Date = as.Date(t0+(time-1)))
    
    # Join simulated and observed data
    mod.obs.dat <- mod.run %>% 
      full_join(fit_data, by = "Date")
    
    ## Calculate the log likelihood (logLike) of the data given theta (parameter set)
  	hosp.sse <- (mod.obs.dat$HOSP_CONF+mod.obs.dat$ICU_CONF - mod.obs.dat$H)^2 
  	mort.sse <- (mod.obs.dat$D - mod.obs.dat$cum_death)^2

  	return(sum(hosp.sse+mort.sse, na.rm = T))
  }

```

```{r fit, eval = FALSE}
iterations <- 1000

set.seed(430)

E.start = rnbinom(iterations, mu = 3, size = 30)+1
beta = rbeta(iterations, 4, 2)
alpha = rbeta(iterations, 2,40)
mu = rbeta(iterations, 3, 12)
db1 = beta*rbeta(iterations, 4, 2)       # Change in transmission from school closure to SiP
db2 = db1*rbeta(iterations, 4, 2)        # Change in transmission 4-15
db3 = db2*(1-rnorm(iterations, 0, 0.2))  # Change in transmission 5-15
db4 = db3*(1-rnorm(iterations, 0, 0.1))  # Change in transmission today

prop.pars <- cbind(E.start, beta, alpha, mu,
                   db1, db2, db3, db4)

lemma_sweeps <- as.list(data.frame(t(prop.pars)))

start <- Sys.time()
lemma_fits <- lapply(lemma_sweeps, lemma_fit,
                     lemma_pars, sf_all)
end <- Sys.time()

end-start

lemma_rslts <- cbind(prop.pars, t(data.frame(lemma_fits)))

```

```{r fit_parallel, eval = FALSE}
iterations <- 100000

set.seed(430)

E.start = rnbinom(iterations, mu = 3, size = 30)+1
beta = rbeta(iterations, 4, 2)
alpha = rbeta(iterations, 2,40)
mu = rbeta(iterations, 3, 12)
db1 = beta*rbeta(iterations, 4, 2)       # Change in transmission from school closure to SiP
db2 = db1*rbeta(iterations, 4, 2)        # Change in transmission 4-15
db3 = db2*(1-rnorm(iterations, 0, 0.2))  # Change in transmission 5-15
db4 = db3*(1-rnorm(iterations, 0, 0.1))  # Change in transmission today

prop.pars <- cbind(E.start, beta, alpha, mu,
                   db1, db2, db3, db4)

as.data.frame(prop.pars) %>% 
  pivot_longer(E.start:db4, names_to = "Par") %>% 
  ggplot() +
    geom_density(aes(value, fill = Par), alpha = 0.5) +
    facet_wrap(Par~., ncol = 4, nrow = 2,
               scales = "free")

lemma_sweeps <- as.list(data.frame(t(prop.pars)))

require(parallel)
opclust <- makeCluster(detectCores())         # Make cluster
clusterExport(opclust, c("lemma_sweeps",
                         "lemma_pars", 
                         "lemma_fit",
                         "sf_all",
                         "lemma_odes",
                         "beta.time",
                         "t0"))         # Export objects to cluster

clusterEvalQ(opclust, {
  library(deSolve)
  library(tidyverse)
})

lemma_fits <- parLapply(opclust, lemma_sweeps, lemma_fit, 
                        lemma_pars, sf_all)

stopCluster(opclust)

lemma_rslts <- cbind(prop.pars, t(data.frame(lemma_fits)))

saveRDS(lemma_rslts, 
        "LEMMA_ODE_sweeps_6-7-20.rds")
```

```{r improve_fit, eval = FALSE}
lemma_rslts <- readRDS("LEMMA_ODE_sweeps_6-7-20.rds")

#Function to return fit from input log parameters and data
  lemma_fit_log <- function(fit.pars, all.pars, fit_data) {
    use.pars <- all.pars
    use.pars[["alpha"]] <- exp(fit.pars[3])
    use.pars[["mu"]] <- exp(fit.pars[4])
    
    beta_smooth <- splinefun(x = beta.time[2:6,1],
                             y = log(exp(c(fit.pars[2],
                                           fit.pars[5],
                                           fit.pars[6],
                                           fit.pars[7],
                                           fit.pars[8]))),
                             method = "natural")
  
    beta_fx <- approxfun(c(1:use.pars[["t.sim"]]),
                         c(log(rep(exp(fit.pars[2]),beta.time[2,1])), 
                           sapply(c(beta.time[2,1]+1):use.pars[["t.sim"]],
                                  beta_smooth)))

    # initial number of exposed as parameter
    init <- c(S = use.pars[["N"]] - exp(fit.pars[1]),
              E = exp(fit.pars[1]),
              Ir = 0,
              Ih = 0,
              H = 0,
              D = 0,
              R = 0)
    
    # Run the model with input parameters to generate predicted quantities
    mod.run <- as.data.frame(ode(y = init, 
                                 times = 1:use.pars[["t.sim"]], 
                                 parms = use.pars,
                                 func = lemma_odes, 
                                 fx = beta_fx)) %>% 
      mutate(Date = as.Date(t0+(time-1)))
    
    # Join simulated and observed data
    mod.obs.dat <- mod.run %>% 
      full_join(fit_data, by = "Date")
    
    ## Calculate the log likelihood (logLike) of the data given theta (parameter set)
  	hosp.sse <- (mod.obs.dat$HOSP_CONF+mod.obs.dat$ICU_CONF - mod.obs.dat$H)^2 
  	mort.sse <- (mod.obs.dat$D - mod.obs.dat$cum_death)^2

  	return(sum(hosp.sse+mort.sse, na.rm = T))
  }

best_pt <- optim(par = log(lemma_rslts[which(lemma_rslts[,9] == min(lemma_rslts[,9])),][-9]),
                 fn = lemma_fit_log,
                 all.pars = lemma_pars,
                 fit_data = sf_all,
                 method = "L-BFGS-B",
                 lower = log(c(1, 1e-2, 1e-2, 1e-2,1e-2,1e-2,1e-2,1e-2)),
                 upper = log(c(15, 0.9, 0.3, 0.3,1,1,1,1)),
                 control = list(maxit = 1000,
                                trace = 1))

best_pt_pars <- exp(best_pt$par)

saveRDS(best_pt_pars, "LEMMA_ODE_best_fit_pars_6-7-20.rds")
```

```{r sim_best, include = FALSE}
best_pt_pars <- readRDS("LEMMA_ODE_best_fit_pars_6-7-20.rds")

best.pars <- lemma_pars
best.pars[["E.start"]] <- as.numeric(best_pt_pars[1])
best.pars[["alpha"]] <- as.numeric(best_pt_pars[3])
best.pars[["mu"]] <- as.numeric(best_pt_pars[4])

  init <- c(S = as.numeric(best.pars[["N"]] - round(best.pars[["E.start"]])),
            E = as.numeric(round(best.pars[["E.start"]])),
            Ir = 0,
            Ih = 0,
            H = 0,
            D = 0,
            R = 0)
  
  best_spline <- splinefun(x = beta.time[1:6,1],
                           y = log(c(best_pt_pars[2],best_pt_pars[2],
                                     as.numeric(best_pt_pars[5:8]))),
                           method = "natural")
  
  best_smooth <- approxfun(c(1:best.pars[["t.sim"]]),
                           c(rep(log(best_pt_pars[2]),beta.time[2,1]), 
                             sapply(c(beta.time[2,1]+1):best.pars[["t.sim"]],
                                    best_spline)),
                           method = "constant")

plot(c(1:best.pars[["t.sim"]]), exp(sapply(1:best.pars[["t.sim"]], best_smooth)), 
     type = "l")
  points(x = beta.time[1:6,1],
         y = c(best_pt_pars[2],best_pt_pars[2],
                   as.numeric(best_pt_pars[5:8])),
         pch = 17, col = "red")
```

```{r best_pars, dev="tikz" }
tab1 <- data.frame(val = as.character(round(as.numeric(best.pars), 3)), 
                   des = c("population size",
                           "time to run simulation",
                           "starting number of exposed",
                           "Relative contact rate between S and Ir",
                           "Relative contact rate between S and Ih",
                           "1/serial interval",
                           "proportion severely symptomatic (will be hospitalized)",
                           "time between symptom onset and hospitalization",
                           "1/time to recovery (non-infectiousness) for mildly symptomatic",
                           "1/time hospitalized",
                           "proportion of hospitalized cases who die"))

rownames(tab1) <- c("$N$", "t.sim", "$E_0$" ,"$c_r$","$c_h$",
                    "$\\sigma$","$\\alpha$", "$\\rho$", 
                    "$\\gamma_r$","$\\gamma_h$","$\\mu$")

knitr::kable(tab1, row.names = TRUE, 
             col.names = c("Value", "Definition"), 
             format = "latex", escape = FALSE, 
             caption = "Best fit model parameters")
```

```{r plot_best}
best.sim <- as.data.frame(ode(y = init, 
                              times = 1:best.pars[["t.sim"]], 
                              parms = best.pars,
                              func = lemma_odes, 
                              fx = best_smooth)) %>% 
  mutate(Date = as.Date(t0+time-1),
         I_tot = Ir+Ih) 

best.sim$Re <- get_R(exp(sapply(1:best.pars[["t.sim"]], best_smooth)),
                     best.pars[["alpha"]], best.pars[["gam_r"]], best.pars[["rho"]], best.sim$S, best.pars[["N"]])

ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_col(data = sf_all,
             aes(x = Date, y = HOSP_CONF+ICU_CONF)) +
  geom_line(data = best.sim,
            aes(x = Date, y = H),
            col = "coral", size = 1.2) +
  scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day") +
  labs(x = "Date", y = "Hospitalizations",
       title = "Model fit to SF hospitalizations")

ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_col(data = sf_all,
             aes(x = Date, y = cum_death)) +
  geom_line(data = best.sim,
            aes(x = Date, y = D),
            col = "coral", size = 1.2) +
  scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day") +
  labs(x = "Date", y = "Cumulative deaths",
       title = "Model fit to SF deaths")

ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_line(data = best.sim,
            aes(x = Date, y = Re),
            col = "coral", size = 1.2) +
  scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day") +
  scale_y_continuous(breaks = seq(0,3.5,0.5),
                     limits = c(0,4)) +
  labs(x = "Date", y = expression(R[e]),
       title = "Best fit effective reproduction number")

```

### Comparison to testing data  
```{r comp_test}
sf_test_p_inc <- rbind(sf_test_plot_df,
      best.sim %>% 
        mutate(Test = " Modeled Cases",
               Num = I_tot/best.pars[["N"]]*100000) %>% 
        dplyr::select(Date,Test,Num))

sf_test_p_inc %>% 
  ggplot() +
    geom_line(aes(x = Date, y = Num, col = Test),
              size = 1.1) +
    theme_bw() +
    scale_color_manual(values = c("darkblue", "purple", "gold"),
                       labels = c("Modeled\nCases/100k",
                                  "n positive",
                                  "Tests\n conducted (100s)")) +
    scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day") +
    theme(axis.title = element_text(size = 14,
                                    face = "bold"),
          axis.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45,
                                     hjust = 1)) +
    labs(x = "Date", y = "",
         title = "SF COVID testing and modeled cases",
         col = "")

```

```{r test_mod_comp}
sf_test_mod_join <- sf_test %>% 
  left_join(best.sim, by = "Date") %>% 
  mutate(tests_7dayavg = zoo::rollmean(tests,7,na.pad = T,align = "right"),
         pos_7day_avg = zoo::rollmean(pos,7,na.pad = T,align = "right"),
         H_new = Ih*best.pars[["rho"]],
         I_new = E*best.pars[["sigma"]],
         Ir_new = E*(1-best.pars[["alpha"]])*best.pars[["sigma"]],
         Ih_new = E*best.pars[["alpha"]]*best.pars[["sigma"]])

sf_test_mod_join %>% 
  mutate(tests_100_avg = tests_7dayavg/100,
         pos_p1000_avg = pos_7day_avg/1000,
         H_new_p100 = H_new/100,
         I_new_p1000 = I_new/1000) %>% 
  dplyr::select(Date, tests_100_avg, pos_7day_avg, H_new, I_new) %>% 
  pivot_longer(-Date, names_to = "Var") %>%
  ggplot() +
    geom_line(aes(x = Date, y = value, col = Var),
              size = 1.1) +
    theme_bw() +
    scale_color_manual(values = c("darkred", "darkgreen", "purple", "gold"),
                       labels = c("Mod H admissions",
                                  "Mod I incidence",
                                  "Positives",
                                  "Tests (100s)")) +
    scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day") +
    theme(axis.title = element_text(size = 14,
                                    face = "bold"),
          axis.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45,
                                     hjust = 1)) +
    labs(x = "Date", y = "",
         title = "SF COVID testing and model",
         col = "")

```

#### Match modeled testing to observed testing  
Assume all new hospitalized cases are tested and confirmed positive, then assume remaining tests are allocated to non-hospitalized population. In the model, this is equivalent to a sample of $S$, $E$, and $I_r+I_h$. In reality, lots of nuance in the $E$ and $R$ compartments with regard to testing, but for simplicity, we'll assume positive tests from this sample only come from $I_r+I_h$ and $R$s are not tested. So want to solve for sampling bias, $\mathcal{B}$, from:
$$\frac{+Tests-H_{new}}{Tests-H_{new}}=\frac{\mathcal{B}(I_r+I_h)}{S+E+I_r+I_h}$$

```{r mod_test_match, fig.cap="Distribution of estimated sampling bias since end of April"}
sf_test_mod_join_samp_bias <- sf_test_mod_join %>% 
  mutate(tests_100_avg = tests_7dayavg/100,
         mod_SE = S+E,
         tests_non_H = tests - round(H_new),
         pos_non_H = pos - round(H_new),
         non_H_pos_rate = pos_non_H/tests_non_H,
         mod_I_prev = I_tot/(mod_SE+I_tot),
         bias = non_H_pos_rate/mod_I_prev)

boxplot(sf_test_mod_join_samp_bias %>% 
          filter(Date >= as.Date("2020-04-30")) %>% 
          pull(bias),
        ylab = "Bias")

```

```{r bias_through_time}
sf_test_mod_join_samp_bias %>% 
  filter(Date >= (as.Date("2020-03-15"))) %>% 
  mutate(bias_7dayavg = zoo::rollmean(bias, 7, 
                                      na.pad = T, align = "right")) %>% 
  ggplot() +
    geom_line(aes(x = Date, y = bias_7dayavg),
              size = 1.1) +
    theme_bw() +
    scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day") +
    scale_y_continuous(breaks = c(25,50,75,100,125),
                       limits = c(25,125)) +
    theme(axis.title = element_text(size = 14,
                                    face = "bold"),
          axis.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45,
                                     hjust = 1)) +
    labs(x = "Date", y = "Testing bias",
         title = "SF COVID testing bias through time")

```


```{r test_mod_test_match, eval = FALSE}
#Simulate biased testing of modeled data
test_with_bias <- function(p_tests, n_tests, mod_I, mod_H, mod_SE){
  B <- (p_tests-round(mod_H))/(n_tests-round(mod_H))*(mod_SE/mod_I)
  t_samp <- sample(c(rep(0, mod_SE),
                     rep(1, mod_I)),
                   n_tests-round(mod_H),
                   prob = c(rep(1, mod_SE),
                            rep(B, mod_I)))
  
  pct_pos <- sum(t_samp)/(n_tests-round(mod_H))
  
  return(pct_pos)
}

n_sim_tests <- 30

sim_tests_mat <- matrix(NA, ncol = n_sim_tests, 
                        nrow = nrow(sf_test_mod_join_samp_bias %>% 
                                      filter(Date >= as.Date("2020-03-15")) %>% 
                                      drop_na()))

set.seed(430)

for(i in 1:n_sim_tests){
  sim_tests_mat[,i] <- apply(sf_test_mod_join_samp_bias %>% 
                               filter(Date >= as.Date("2020-03-15")) %>% 
                               drop_na(),
                             1, function(t){
                               test_with_bias(as.numeric(t["pos"]), as.numeric(t["tests"]),
                                              as.numeric(t["I_tot"]), as.numeric(t["H_new"]), 
                                              as.numeric(t["mod_SE"]))
                             })
  print(i)
}

saveRDS(sim_tests_mat,
        "sim_test_pct_pos_6-7-20.rds")
```


```{r test_mod_pct_comp}
sim_tests_mat <- readRDS("sim_test_pct_pos_6-7-20.rds")

sim_tests_pos_med <- apply(sim_tests_mat, 1, median)
sim_tests_75th <- apply(sim_tests_mat, 1, quantile, 0.75)
sim_tests_25th <- apply(sim_tests_mat, 1, quantile, 0.25)

as.data.frame(cbind(sf_test_mod_join_samp_bias %>% 
                               filter(Date >= as.Date("2020-03-15")) %>% 
                               drop_na(),
                    sim_tests_pos_med, sim_tests_25th, sim_tests_75th)) %>% 
  ggplot() +
    theme_bw() +
    geom_point(aes(x = non_H_pos_rate, y = sim_tests_pos_med)) +
    geom_errorbar(aes(x = non_H_pos_rate, 
                      ymin = sim_tests_25th,
                      ymax = sim_tests_75th)) +
    geom_abline(intercept = 0, slope = 1, lty = 2) +
    labs(x = "Observed test positive rate minus H admissions",
         y = "Simulated test positive rate",
         title = "Comparison of simulated and observed test positive rates adjusting for bias")
```


## Model forecast  

```{r sim.extended, eval = FALSE}
spline_ext <- splinefun(x = beta.time[,1],
                        y = as.numeric(log(c(best_pt_pars[2],best_pt_pars[2],
                                  as.numeric(best_pt_pars[5:8]), 
                                  get_beta(1.4, best_pt_pars[3], 
                                           best.pars[["gam_r"]], best.pars[["rho"]])))),
                        method = "natural")

smooth_ext <- approxfun(c(0:t.tot),
                        c(rep(log(best_pt_pars[2]),beta.time[2,1]), 
                          sapply(c(beta.time[2,1]+1):(t.tot+1),
                                 spline_ext)))


sim.ext <- as.data.frame(ode(y = init, 
                             times = 1:t.tot, 
                             parms = best.pars,
                             func = lemma_odes, 
                             fx = smooth_ext)) %>% 
  mutate(Date = as.Date(t0+time-1)) 

sim.ext$Re <- get_R(exp(sapply(1:t.tot, smooth_ext)),
                    best.pars[["alpha"]], best.pars[["gam_r"]], best.pars[["rho"]], 
                    sim.ext$S, best.pars[["N"]])

ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_line(data = sim.ext,
            aes(x = Date, y = H),
            col = "coral", size = 1.2) +
  geom_point(data = sf_all,
             aes(x = Date, y = HOSP_CONF+ICU_CONF),
             pch = 17) +
  scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day",
               limits = c(as.Date("2020-02-15"), t.end))

ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_line(data = sim.ext,
            aes(x = Date, y = D),
            col = "coral", size = 1.2) +
  geom_point(data = sf_all,
             aes(x = Date, y = cum_death),
             pch = 17) +
  scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day",
               limits = c(as.Date("2020-02-15"), t.end))

ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_line(data = sim.ext,
            aes(x = Date, y = Re),
            col = "coral", size = 1.2) +
  scale_x_date(date_labels = "%m/%d", 
               date_breaks = "7 day",
               limits = c(as.Date("2020-02-15"), t.end)) +
  scale_y_continuous(breaks = seq(0,3.5,0.5),
                     limits = c(0,4))

```

```{r adaptau_mod}
library(adaptivetau)

# List of transitions
transitions = list(
  c(S = -1, E = 1),     #Susceptible becomes exposed
  c(E = -1, Ir = 1),    #Exposed becomes Infected, will recover
  c(E = -1, Ih = 1),    #Exposed becomes Infected, will be hospitalized
  c(Ir = -1, R = 1),    #Infected, mild recovers
  c(Ih = -1, H = 1),    #Infected severe becomes hospitalized
  c(H = -1, D = 1),     #Hospitalized, becomes Dead
  c(H = -1, R = 1))     #Hospitalized becomes recovered

# Rate simulator
rates_base <- function(x, p, t, fx) {
  S = x['S']
  E = x['E']
  Ir = x['Ir']
  Ih = x['Ih']
  H = x['H']
  R = x['R']
  D = x["D"]

  # Parameters
    N = p[['N']]             #population size
    beta =future_beta(t)     #transmission rate
    cr = p[['cr']]           #Relative contact rate between S and Ir
    ch = p[['ch']]           #Relative contact rate between S and Ih
    sigma = p[['sigma']]     #1/serial interval
    alpha = p[['alpha']]     #proportion severely symptomatic
    rho = p[['rho']]         #1/time between symptom onset and hospitalization
    gam_r = p[['gam_r']]     #1/time to recovery (non-infectiousness) for mild/asymptomatic
    gam_h = p[['gam_h']]     #1/time to removed (recovered or deceased) for hospitalized
    mu = p[['mu']]           #proportion of hospitalized cases who die
  
  return(c(S*beta*(Ir*cr+Ih*ch)/N, #Susceptible becomes exposed
           E*(1-alpha)*sigma,      #Exposed becomes Infected, pre-symptomatic
           E*alpha*sigma,          #Exposed becomes Infected, asymptomatic
           Ir*gam_r,               #Infected, pre-symptomatic becomes Infected, severe
           Ih*rho,                 #Infected, pre-symptomatic becomes Infected, mild
           H*mu*gam_h,             #Hospitalized becomes Dead
           H*(1-mu)*gam_h))        #Hospitalized becomes recovered
}

#Function to simulate and return dataframe
stoch.sim = function(init, trans, rates, pars, t_sim){
  
  ssa.sim <- adaptivetau::ssa.adaptivetau(init.values = init, 
                                          transitions = trans,
                                          rateFunc = rates,
                                          params = pars,
                                          tf=t_sim)
  
  return(ssa.sim)
}  

#Starting conditions from today
init_today <- as.numeric(round(best.sim[dim(best.sim)[1]-1, 2:8]))
names(init_today) <- colnames(best.sim[2:8])

```

```{r Hadm_mod}
# List of transitions dividing recovered between those that recover from H and Ir for identifiable stoichiometry
transitions_Hadm = list(
  c(S = -1, E = 1),     #Susceptible becomes exposed
  c(E = -1, Ir = 1),    #Exposed becomes Infected, will recover
  c(E = -1, Ih = 1),    #Exposed becomes Infected, will be hospitalized
  c(Ir = -1, Rr = 1),   #Infected, mild recovers
  c(Ih = -1, H = 1),    #Infected severe becomes hospitalized
  c(H = -1, D = 1),     #Hospitalized, becomes Dead
  c(H = -1, Rh = 1))     #Hospitalized becomes recovered

# Rate simulator
rates_Hadm <- function(x, p, t, fx) {
  S = x['S']
  E = x['E']
  Ir = x['Ir']
  Ih = x['Ih']
  H = x['H']
  Rr = x['Rr']
  Rh = x['Rh']
  D = x["D"]

  # Parameters
    N = p[['N']]             #population size
    beta =future_beta(t)     #transmission rate
    cr = p[['cr']]           #Relative contact rate between S and Ir
    ch = p[['ch']]           #Relative contact rate between S and Ih
    sigma = p[['sigma']]     #1/serial interval
    alpha = p[['alpha']]     #proportion severely symptomatic
    rho = p[['rho']]         #1/time between symptom onset and hospitalization
    gam_r = p[['gam_r']]     #1/time to recovery (non-infectiousness) for mild/asymptomatic
    gam_h = p[['gam_h']]     #1/time to removed (recovered or deceased) for hospitalized
    mu = p[['mu']]           #proportion of hospitalized cases who die
  
  return(c(S*beta*(Ir*cr+Ih*ch)/N, #Susceptible becomes exposed
           E*(1-alpha)*sigma,      #Exposed becomes Infected, pre-symptomatic
           E*alpha*sigma,          #Exposed becomes Infected, asymptomatic
           Ir*gam_r,               #Infected, pre-symptomatic becomes Infected, severe
           Ih*rho,                 #Infected, pre-symptomatic becomes Infected, mild
           H*mu*gam_h,             #Hospitalized becomes Dead
           H*(1-mu)*gam_h))        #Hospitalized becomes recovered
}

# Initial conditions with Rr and Rh
init_Hadm <- as.numeric(round(best.sim[dim(best.sim)[1]-1, 2:7]))
init_Hadm <- c(init_Hadm, as.numeric(round(best.sim[dim(best.sim)[1]-1, 8]*c(0.95,0.05))))

names(init_Hadm) <- c(colnames(best.sim[2:7]), "Rr", "Rh")

```


### $\mathcal{R}_e\rightarrow1.4$  

```{r stoch_sims_setup}
#Function for future beta conditions
end.date <- as.Date("2020-08-01")
t.future <- as.numeric(end.date - as.Date("2020-06-03"))

new.Re <- 1.4 
new.beta <- get_beta(new.Re, best.pars[["alpha"]], 
                     best.pars[["gam_r"]], best.pars[["rho"]])
t_til_new_beta <- 7
future_beta <- approxfun(c(0, t_til_new_beta,t.future),
                           c(best_pt_pars[8], new.beta, new.beta),
                           method = "linear")

```

```{r r14_sims, eval = FALSE}
future_runs <- bind_rows(lapply(1:100, function(i){
  as.data.frame(stoch.sim(init = init_today, 
                          trans = transitions, 
                          rates = rates_base,
                          pars = best.pars,
                          t_sim = t.future)) %>% 
    mutate(sim = i,
           dt = time-lag(time),
           tests = round(dt*1600),
           datetime = as.POSIXct(sf_test$result_date[94])+(time*86400))
  }))

future_runs_Hadm <- bind_rows(lapply(1:100, function(i){
  as.data.frame(stoch.sim(init = init_Hadm, 
                          trans = transitions_Hadm, 
                          rates = rates_Hadm,
                          pars = best.pars,
                          t_sim = t.future)) %>% 
    mutate(sim = i,
           dt = time-lag(time),
           tests = round(dt*1600),
           datetime = as.POSIXct(sf_test$result_date[94])+(time*86400))
  }))

saveRDS(future_runs_Hadm,
        "future_stoch_runs_Hadm_Re14_6-7-20.rds")
```

```{r r14_sims_plot}
future_runs_Hadm <- readRDS("future_stoch_runs_Hadm_Re14_6-7-20.rds")

ggplot() +
  theme_bw() +
  theme(axis.title = element_text(size = 14,
                                  face = "bold"),
        axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 45,
                                   hjust = 1)) +
  geom_col(data = sf_all,
           aes(x = as.POSIXct(Date), y = HOSP_CONF+ICU_CONF))  +
  geom_line(data = best.sim,
            aes(x = as.POSIXct(Date), y = H),
            col = "coral", size = 1.2) +
  geom_line(data = future_runs_Hadm,
            aes(x = datetime, y = H, group = as.factor(sim)),
            size = 0.2, col = "grey50", alpha = 0.6) +
  labs(x = "Date", y = "Hospitalizations",
       title = paste("Projected Hospital Census with \nRe reaching ", 
                     new.Re, " in ", t_til_new_beta, " days\nand remaining until",
                     end.date))

```

```{r plot_stoch_sims_Hadm14, include = FALSE}
future_runs_Hadm <- future_runs_Hadm %>% 
  group_by(sim) %>% 
  mutate(dH = H - lag(H),
         dRh = Rh - lag(Rh),
         dD = D-lag(D),
         outH = dRh + dD,
         newH = dH+outH,
         tests_noH = tests-newH,
         tests_use = if_else(tests_noH < 1, NA_real_, tests_noH),
         Date = as.Date(datetime))

future_runs_Hadm %>% 
  drop_na() %>% 
  group_by(Date,sim) %>% 
  summarise(H_adm = sum(newH, na.rm = T)) %>% 
  filter(Date != as.Date("2020-08-01")) %>%
  ggplot() +
    theme_bw() +
    theme(axis.title = element_text(size = 14,
                                    face = "bold"),
          axis.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45,
                                     hjust = 1)) +
  geom_line(aes(x = Date, y = H_adm, group = as.factor(sim)),
            size = 0.2, col = "grey50", alpha = 0.6) +
  labs(x = "Date", y = "Hospital admissions",
       title = paste("Projected Hospital Admissions with \nRe reaching ", 
                     new.Re, " in ", t_til_new_beta, " days\nand remaining until",
                     end.date))

```


```{r future_test_pos, eval = FALSE}
# Function from here to speed up random sampling w/o replacement: https://stackoverflow.com/questions/15113650/faster-weighted-sampling-without-replacement 
weighted_Random_Sample <- function(
    .data,
    .weights,
    .n
    ){

    key <- runif(length(.data)) ^ (1 / .weights)
    return(.data[order(key, decreasing=TRUE)][1:.n])
}

#start <- Sys.time()
test_cl <- makeCluster(detectCores())         # Make cluster
clusterExport(test_cl, c("future_runs_Hadm", 
                         "weighted_Random_Sample"))         # Export objects to cluster

clusterEvalQ(test_cl, require(tidyverse))

stoch_sim_tests <- parApply(test_cl, future_runs_Hadm %>% drop_na() %>% filter(sim < 21), 1, 
                            function(t){
                              t <- as.numeric(t)
                              
                              inf_status <- c(rep(0, (t[2]+t[3])),    # Ss and Es
                                                 rep(1, (t[4]+t[5]))) # Irs and Ihs
                              samps <- t[12]-t[18]                  # number tests minus hospital admissions
                              probs <- c(rep(1, (t[2]+t[3])),
                                        rep(45, (t[4]+t[5])))       # Sampling bias of 45
                              
                              t_samp <- weighted_Random_Sample(inf_status, probs, samps) 
                              
                              return(sum(t_samp)/(t[12]-t[18]))
                            })

stopCluster(test_cl)
#end <- Sys.time()

#as.numeric(end-start)*nrow(future_runs_Hadm)/360000

saveRDS(stoch_sim_tests, 
        "future_stoch_runs_tests_Re14_6-7-20.rds")

```

```{r plot_stoch_sims_test14}
stoch_sim_tests <- readRDS("future_stoch_runs_tests_Re14_6-7-20.rds")

future_runs_tests_sum <- as.data.frame(cbind(future_runs_Hadm %>% drop_na() %>% filter(sim < 21),
                                           sim_pct_pos = stoch_sim_tests)) %>% 
  arrange(time) %>% 
  mutate(sim_pos = round(sim_pct_pos*tests_use),
         time_cut = cut(time, breaks = c(0:t.future))) %>% 
  group_by(time_cut, sim) %>% 
  summarise(H_adm = sum(newH),
            n_tests = sum(tests),
            n_pos = sum(sim_pos)) %>% 
  mutate(test_pct_pos = n_pos/n_tests,
         time = as.numeric(time_cut),
         Date = as.Date(as.Date("2020-06-03")+time))

  ggplot() +
    theme_bw() +
    theme(axis.title = element_text(size = 14,
                                    face = "bold"),
          axis.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45,
                                     hjust = 1)) +
  geom_line(data = sf_test %>% filter(Date >= as.Date("2020-04-23")),
            aes(x = Date, y = pct),
            size = 1.1)  +
  geom_line(data = future_runs_tests_sum,
            aes(x = Date, y = test_pct_pos, group = as.factor(sim)),
            size = 0.2, col = "grey50", alpha = 0.6) +
  labs(x = "Date", y = "% Positive tests",
       title = "Future Positive test percentages",
       subtitle = "Assuming 1600 tests per day, B=45, Re=1.4 by June 15")

```

```{r plot_Hadm}
future_runs_tests_sum %>% 
  ggplot() +
    theme_bw() +
    theme(axis.title = element_text(size = 14,
                                    face = "bold"),
          axis.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45,
                                     hjust = 1)) +
  geom_line(aes(x = Date, y = H_adm, group = as.factor(sim)),
            size = 0.2, col = "grey50", alpha = 0.6) +
  labs(x = "Date", y = "Hospital admissions",
       title = paste("Projected Hospital Admissions with \nRe reaching ", 
                     new.Re, " in ", t_til_new_beta, " days\nand remaining until",
                     end.date))

```


```{r comp_admissions_pos_tests}
future_runs_tests_sum %>% 
  ggplot() +
    theme_bw() +
    theme(axis.title = element_text(size = 14,
                                    face = "bold"),
          axis.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45,
                                     hjust = 1)) +
  geom_line(aes(x = Date, y = n_pos, group = as.factor(sim)),
            size = 0.2, col = "blue", alpha = 0.6) +
  geom_line(aes(x = Date, y = H_adm, group = as.factor(sim)),
            size = 0.2, col = "red", alpha = 0.6) +
  labs(x = "Date", y = "Metrics",
       title = "Simulations of potential SiP Triggers",
       subtitle = "Assuming 1600 tests per day, B=45, Re=1.4 by June 15\nBlue-positive tests,    Red-Hospital admissions")

```

```{r trigger_metrics}
future_runs_tests_sum %>% 
  group_by(Date) %>% 
    summarise(mean_pctPos = mean(test_pct_pos),
              mean_n_pos = mean(n_pos),
              mean_H_adm = mean(H_adm)) %>% 
    mutate(`Pct Pos 3day` = zoo::rollmean(mean_pctPos,3, na.pad = T),
           `N Pos 3day` = zoo::rollmean(mean_n_pos,3, na.pad = T),
           `H Adm 3day` = zoo::rollmean(mean_H_adm,3, na.pad = T)) %>% 
  pivot_longer(`Pct Pos 3day`:`H Adm 3day`, names_to = "Metric") %>% 
  ggplot() +
    theme_bw() +
    theme(axis.title = element_text(size = 14,
                                    face = "bold"),
          axis.text = element_text(size = 12),
          axis.text.x = element_text(angle = 45,
                                     hjust = 1)) +
    geom_line(aes(x = Date, y = value),
              size = 1.1) +
    facet_grid(Metric~., scales = "free_y")

```

```{r stoch_tests, eval=FALSE}
rates_test <- function(x, p, t, fx) {
  S = x['S']
  E = x['E']
  Ir = x['Ir']
  Ih = x['Ih']
  H = x['H']
  R = x['R']
  D = x["D"]
  
  tested <- sample(c(rep(0, S+E+Ir+Ih),
                     rep(1, Ir+Ih)),
                   1600,
                   prob = c(rep(1, S+E+Ir+Ih),
                            rep(45, Ir+Ih)))
  
  test_pos_rate <- sum(tested)/(S+E+Ir+Ih)
  
  print(test_pos_rate)
  
  # Parameters
    N = p[['N']]             #population size
    beta =future_beta(t)     #transmission rate
    cr = p[['cr']]           #Relative contact rate between S and Ir
    ch = p[['ch']]           #Relative contact rate between S and Ih
    sigma = p[['sigma']]     #1/serial interval
    alpha = p[['alpha']]     #proportion severely symptomatic
    rho = p[['rho']]         #1/time between symptom onset and hospitalization
    gam_r = p[['gam_r']]     #1/time to recovery (non-infectiousness) for mild/asymptomatic
    gam_h = p[['gam_h']]     #1/time to removed (recovered or deceased) for hospitalized
    mu = p[['mu']]           #proportion of hospitalized cases who die
  
  return(c(S*beta*(Ir*cr+Ih*ch)/N, #Susceptible becomes exposed
           E*(1-alpha)*sigma,      #Exposed becomes Infected, pre-symptomatic
           E*alpha*sigma,          #Exposed becomes Infected, asymptomatic
           Ir*gam_r,               #Infected, pre-symptomatic becomes Infected, severe
           Ih*rho,                 #Infected, pre-symptomatic becomes Infected, mild
           H*mu*gam_h,             #Hospitalized becomes Dead
           H*(1-mu)*gam_h))        #Hospitalized becomes recovered
}

stoch.sim(init = init_today, 
          trans = transitions, 
          rates = rates_test,
          pars = best.pars,
          t_sim = t.future)
```

